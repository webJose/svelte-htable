# svelte-htable

This is a hierarchical table component for Svelte.  This means that it is a table that may be provided with items that 
contain items, and said contained items need to be displayed as a sub-table.  The process can be repeated, producing 
an arbitrary amount of nested tables.  An image is worth a thousand words:

![svelte-htable example](example.png)

The styling shown in the example is not provided in the component itself.  It must be provided by assigning a CSS 
class to the table or by styling the `<table>` element and its sub-elements (`<th>`, `<td>`, etc).  Inner tables 
inherit any CSS classes that are applied to the parent, but further styling can be applied down the sub tables.  See 
the [Styling the Table](#styling-the-table) section of this ReadMe for details on the matter.

## Features

1. It is a recursive component.
2. Sub-tables can show a path and a level on top of it (this uses the table's `<caption>` element).
3. Sub-tables can be targetted for further styling.
4. It can group items so all items with sub-items are grouped together either before or after the items with no 
sub-items.
5. The summary of the elements with sub-items can be specified freely using either the value of a property or 
completely arbitrary logic using a function.
6. The path in sub-tables can be generated by the value of a property or by using a function.

## Quickstart

Install the package:

```bash
npm i svelte-htable
```

Now use it as `<Htable />` in a page or component.  The following example is in TypeScript to show how to extend the 
`Item` type to have Intellisense.  This is optional, as all of TypeScript.  Feel free to use JavaScript if you want.

**NOTE**:  This is an example use in a Svelte page (it receives the data from its `load()` function).

```ts
<script lang="ts">
    import
        Htable, { // Table component.
        CaptionOrder, // Enumeration to control the order of the data in captions.
        ItemGrouping, // Enumeration to control the item grouping behavior.
        type Column, // TypeScript type.  It represents a single table column definition.
        type Item, // Base TypeScript item type.  Extend this type as shown below.
    } from "svelte-htable";

    interface DataItem extends Item {
        first_name: string;
        last_name: string;
        email: string;
        gender: string;
        country_code: string;
        manager_id: number;
    }
    // This page expects the data to be provided through its load() function (Svelte stuff).
    export let data: { data: DataItem[] };
    // Define your table columns.
    const columns: Column[] = [
        {
            key: "id", // property name in the JS object
            title: "ID", // title shown in the column header
        },
        {
            key: "first_name",
            title: "First Name",
        },
        {
            key: "last_name",
            title: "Last Name",
        },
        {
            key: "email",
            title: "Email",
        },
        {
            key: "gender",
            title: "Gender",
        },
        {
            key: "country_code",
            title: "Country Code",
        },
        {
            key: "manager_id",
            title: "Manager's ID",
        },
    ];
</script>
<!-- Now use the component. -->
<Htable
    class="data"
    items={data.data}
    {columns}
    showLevel={true}
    showPath={true}
    captionOrder={CaptionOrder.LevelPath}
    expansibleTitle={(i) => `${i.last_name}, ${i.first_name}`}
    grouping={ItemGrouping.ExpansiblesFirst}
    pathSegment={(i) => i.last_name}
    pathSeparator=" > "
    maxPathSegmentLength={10}
/>
```

## Required Data Structure

If you haven't realized yet, your data needs to follow a specific structure.  Each item is expected to have `id` and 
`subItems` properties as per the definition of the `Item` data type.  Data items with a non-empty array in their 
`subItems` property will generate a sub-table, whose rows will be generated from the data items found in said array.

## Styling the Table

There are two ways to style the tables generated by `svelte-htable`.  The most straightforward approach would be to 
target the `<table>` element using a regular CSS file (so the classes are not scoped to a component), or a Svelte 
page/component file using `:global()` to avoid Svelte from scoping the CSS.  Then the table automatically picks the 
styles up as per the usual CSS rules.

The second way is to apply a CSS class to the component, declaring its styles either in a regular CSS file or a Svelte 
page/component file with `:global()`.  I would say this is probably the saner option because most likely you don't 
want to target other tables in your project by mistake.  The quickstart example uses this one.

This should cover the basics for styling, but the component allows finer targetting of its internal parts.

### Styling Sub-Tables

All sub-tables are decorated with the `sub` CSS class and also inherit the parent's CSS class.  This means that one 
can write CSS selectors of the form `table.sub` (or `:global(table.sub)`) to only target sub-tables.  The 
screenshot shown in this ReadMe was done by using this technique to apply sub-tables a different background color.

Furthermore, the `sub-X` CSS class is applied to the tables, where `X` is the table's level.  The main table is level 
1, while all immediate sub-tables are level 2.  The main table has no extra CSS classes; the immediate sub-tables will 
have the `sub` and `sub-2` CSS classes.

### Styling Expansibles

The expansibles are `<details>` HTML elements.  As per their usage, what is shown when the contents are collapsed is 
inside a `<summary>` HTML element.  You may style by targetting this element.  This is an example CSS that assumes the 
tables have been applied the `data` CSS class:

```css
table.data details > summary {
    /* Add the CSS for what is visible when the elements are collapsed. */
}
```

This `<details>` element spans all table columns.  The row that contains the element is further applied a `sub` CSS 
class to help styling.  An equivalent to the above could be:

```css
table.data tr.sub details > summary {
    /* Add the CSS for what is visible when the elements are collapsed. */
}
```

This is more specific than the previous example, so this should help in case specificity comes into play.

### Styling Sub-Table Captions

Sub-tables can show a caption on top with two pieces of information:  The table's level and a **path** value.  Since this 
is a table that displays hierarchical data, the concept of a path should be natural, and this is what is meant to be 
shown in the table's caption.  See the next section for information about this and other features.

The table's caption (a `<caption>` HTML element) is made up of two `<span>` elements.  Eaach element is assigned a CSS 
class based on its position.  The one to the left has the `ct-l` CSS class; the one to the right, `ct-r`.  Use these 
classes to style the pieces of information shown in the caption.  What's shown to the left or the right depends on the 
value of the `captionOrder` prop as explained in the next section.

## Htable's Props

The following is the complete list of supported props:

| Property | Type | Description | Example |
| - | - | - | - |
| `columns` | `Column[]` | Required.  Column definitions. | `[{ key: 'id', name: 'ID'}]` |
| `items` | `Item[]` | Required.  Data items. | `[{ id: 1, name: 'John', subIems: [{ id: 2, name: 'Clara' }]}]` |
| `class` | String | Optional.  Used to apply CSS class(es). | `"my-css-data-table"` |
| `showLevel` | Boolean | Optional (defaults to `false`).  Set to true to show the sub-tables' level in their captions. | `true` |
| `showPath` | Boolean | Optional (defaults to `false`).  Set to true to show the sub-tables' path in their captions. | `true` |
| `pathSeparator` | String | Optional (defaults to `'.'`).  Divider used to join path segments to create sub-tables' paths. | `' > '` |
| `captionOrder` | Number (`CaptionOrder`) | Optional (defaults to `CaptionOrder.PathLevel`).  Specifies which data goes where in sub-tables' captions. | `CaptionOrder.LevelPath` |
| `grouping` | Number (`ItemGrouping`) | Optional (defaults to `ItemGrouping.ExpansiblesFirst`).  Specifies how to group data items based on the existence of sub-items in them. | `ItemGrouping.ExpansiblesLast` |
| `summary` | `string \| ((item: Item) => string)` | Optional.  Used to control what is shown as the expansible item's summary. | `i => i.name` |
| `pathSegment` | `string \| ((item: Item) => string)` | Optional.  Used to define sub-tables' paths. | `i => i.employeeId` |
| `maxPathSegmentLength` | Number | Optional.  If specified, path segments that exceed this length will be truncated. | `10` |
| `buildLevel` | `(level: number) => string` | Optional.  Used to build the text that appears as **Level** in the sub-tables' captions. | `l => 'level: ' + l` |

### Caption-Related Props

A sub-table's caption may display up to two pieces of data:  Its level, and its path.  One can specify on which side 
of the caption each value appears using the `captionOrder` prop, and whether or not they appear using the `showLevel` and `showPath` props.

The `captionOrder` prop accepts any value of the `CaptionOrder` enumeration:

| Name | Numerical Value | Description |
| - | - | - |
| `PathLevel` | 1 | The sub-tables' captions will show the table's path to the left and the table's level to the right. |
| `LevelPath` | 2 | The sub-tables' captions will show the table's level to the left and the table's path to the right. |

#### About Path

A sub-table's path is automatically constructed by using the data item's first property as defined by the column 
definitions, unless the `pathSegment` prop is specified with either a data item's property name, or a function that 
takes the data item as function argument and returns the actual path segment value to use.  Each path segment is 
joined with other segments using the value of the `pathSeparator` prop.  If not specified, the default path separator 
is a period (`.`).  Any string can be used as path separator, but since the sub-table's caption's real estate is very 
limited, try not to use long separators.

Because of this limited real estate in captions, and most likely because your data will be dynamic in nature, this 
component allows the specification of a maximum path segment length to help prevent overrunning the available space 
for both the level and the path data.  It works like this:  A path segment's value is obtained and measured against 
the value specified in the `maxPathSegmentLength` prop.  If the length exceeds the specification, then the path segment is 
truncated and ellipsis (`...`) is added at the end, so that the combined length is equal to `maxPathSegmentLength`.

The value of `maxPathSegmentLength` must be greater than 3.

### Grouping Items

It may be desirable to rearrange the tables' rows according to their nature (expansible vs. non-expansible), so this 
component exposes the `grouping` prop.  This prop accepts any value of the `ItemGrouping` enumeration.

| Name | Numerical Value | Description |
| - | - | - |
| `Undefined` | 0 | The provided data items will be presented in the order they were provided. |
| `ExpansiblesFirst` | 1 | The provided data items will be rearranged so the ones with sub-items will be shown first. |
| `ExpansiblesLast` | 2 | The provided data items will be rearranged so the ones with sub-items will be shown last. |

### Defining the Summaries

The summaries are the the text shown for expansible items.  Said items are not (yet) fully displayed and their tabular 
representation is exchanged by a line of text.  This text is defined by the `summary` prop.  If this prop is not 
specified, then the summary will be the property that goes into the first column (defined by the `key` property of the 
first column definition), but if specified, it can either be the name of another property found in the data item, or 
it can be a function that receives the data item as argument and returns the summary's content.

This example creates sub-tables whose summary is the concatenation of the first and last names found in the data item:

```ts
<Htable
    ...
    summary={i => `${i.last_name}, ${i.first_name}`}
/>
```
